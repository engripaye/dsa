## ** DSA PRACTICE **

### *1. Arrays & Hashing*  
1. *Two Sum* → Find two numbers in an array that sum to a target. (HashMap approach for O(N) solution)  
2. *Contains Duplicate* → Check if an array contains duplicates. (Use HashSet for O(N) time)  
3. *Valid Anagram* → Check if two strings are anagrams of each other. (Use character frequency map)  
4. *Intersection of Two Arrays* → Find the common elements between two arrays. (Use HashSet for O(N) solution)  

---

### *2. Strings*  
5. *Reverse a String* → Given "hello", return "olleh". (Use two pointers)  
6. *Longest Substring Without Repeating Characters* → Find the longest unique character substring. (Use Sliding Window technique)  
7. *Valid Palindrome* → Check if a string is a palindrome (ignoring spaces and case). (Use two pointers)  
8. *Find the First Non-Repeating Character* → Given "aabbcdd", return "c". (Use HashMap to store character frequency)  

---

### *3. Two Pointers*  
9. *Remove Duplicates from Sorted Array* → Remove duplicates in-place in a sorted array.  
10. *Move Zeroes* → Move all zeroes to the end while maintaining order.  
11. *Reverse a Linked List* → Reverse a singly linked list iteratively.  

---

### *4. Stack & Queue*  
12. *Valid Parentheses* → Check if a string of brackets is balanced. (Use Stack)  
13. *Min Stack* → Implement a stack that supports push, pop, and retrieving the minimum in O(1). (Use an auxiliary stack)  
14. *Implement Queue using Stacks* → Use two stacks to implement a queue.  

---

### *5. Searching & Sorting*  
15. *Binary Search* → Find an element in a sorted array in O(log N).  
16. *Search Insert Position* → Return the index where a number should be inserted in a sorted array.  
17. *Merge Sorted Arrays* → Merge two sorted arrays into one sorted array.  

---

### *6. Recursion & Backtracking*  
18. *Factorial of a Number* → Implement recursive factorial.  
19. *Fibonacci Number* → Solve using recursion and optimize using memoization.  
20. *Generate Parentheses* → Generate all valid parentheses combinations for n pairs. (Backtracking problem)  

---

### *7. Linked List*  
21. *Detect Cycle in a Linked List* → Use Floyd’s cycle detection (slow & fast pointer).  
22. *Merge Two Sorted Linked Lists* → Merge two sorted linked lists into one.  
23. *Find Middle of Linked List* → Use the slow and fast pointer technique.  

---

### *8. Trees & Graphs*  
24. *Binary Tree Inorder Traversal* → Implement inorder traversal of a binary tree. (Recursive & Iterative using Stack)  
25. *Lowest Common Ancestor (LCA)* → Find the LCA of two nodes in a Binary Search Tree.  
26. *Graph BFS & DFS Traversal* → Implement *Breadth-First Search* and *Depth-First Search*.  

---

### *9. Dynamic Programming (Beginner Friendly)*  
27. *Climbing Stairs* → Solve using recursion and dynamic programming.  
28. *House Robber* → Solve using dynamic programming to maximize the sum without robbing adjacent houses.  

